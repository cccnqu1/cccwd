<html>
<head>
  <meta charset="utf-8" />
</head>
<body>
<script src="../../gospa.js"></script>
<title> 陳鍾誠  / 教科書  / 計算機結構 / 平行處理 (Parallel) </title>

 [[陳鍾誠]](ccc:home)  / [[教科書]](book:home)  / [[計算機結構]](co:home) 

<h2 id="parallel">平行處理 (Parallel)</h2>

<p>由於散熱等因素無法克服，目前的處理器頻率已經不容易再快速往上調整，但是晶片的密度與容量還再持續增加，於是處理器內的平行，也就是多核心的情況就愈來愈普遍了。</p>

<p>目前雙核心、四核心、八核心甚至 16 核心的處理器已經很常見了，在可見的未來，或許成百上千核心的處理器也會被開發出來，因此如何運用平行技術充份利用這麼多核心將會是一個重要的課題。</p>

<p>另外、網路雲端運算的需求不斷增強，也會進一步增加多處理器技術的重要性，像是 Google 提出的 MapReduce 就在「大數據」的潮流下愈來愈形重要，而 MPI 與 Hadoop 等分散式平行處理技術也就在這種情況下逐漸普及了。</p>

<p>對於平行計算的架構，有一種相當好的分類方式，是根據「指令與資料是單數還複數」所進行的分類，這種分類法將平行架構分為「單指令多資料」(SIMD), 「多指令單資料」(MISD), 「多指令多資料」(MIMD) 等架構，在加上傳統非平行化的「單指令單資料」(SISD) 等形成一個 2*2 的矩陣。</p>

<p>舉例而言，像是上述的 GPU 向量架構，是屬於 SIMD 的平行架構，而下圖中的 UMA 與 NUMA 架構，則是屬於 MIMD 的平行架構。</p>

<div class="figure"><img src="db/co/UMAvsNUMA.jpg"/><p class="caption"></p></div>

<p>當然、在上述架構下，每個處理器理又有自己的 cache ，如何保持這些 cache 的一至性就會是個問題，而解決這些問題所依賴的方法仍然是與快取一至性中的所使用的「寫穿」 (write-through) 和「寫回」 (write-back) 等方法類似，只是規模要放大到整個網路上的快取而已。</p>

</body>
</html>